
import { Model } from './core/logic.js';
import { UiManager } from './ui/ui-manager.js';
import { WorldRenderer } from './canvas/renderer.js';
import './style.css';

// Initialize Core Components
let model, renderer, uiManager;

document.addEventListener('DOMContentLoaded', () => {
    console.log("DOM Loaded. Initializing App...");
    model = new Model();
    renderer = new WorldRenderer(model, 'world-canvas');

    uiManager = new UiManager(model, renderer);
    window.uiManager = uiManager; // Expose for inline events and debugging

    // Hook renderer selection change to UI update
    const originalHandleMouseDown = renderer.handleMouseDown.bind(renderer);
    renderer.handleMouseDown = (e) => {
        originalHandleMouseDown(e);
        uiManager.updateEvaluation();
    };
});



// Setup Drag Data for Toolbar
// Setup Drag Data for Toolbar
// Use event delegation for robustness
document.addEventListener('dragstart', (e) => {
    if (e.target.classList && e.target.classList.contains('toolbar-item')) {
        e.dataTransfer.setData('type', e.target.dataset.type);
        e.dataTransfer.effectAllowed = 'copy'; // Explicitly allow copy
        if (e.target.dataset.op) {
            e.dataTransfer.setData('op', e.target.dataset.op);
        }
    }
});

console.log('LogosCanvas Initialized with Model, Renderer, and UI.');

// --- Export LaTeX Logic ---
const exportModal = document.getElementById('export-modal');
const exportTextarea = document.getElementById('export-textarea');
const exportCloseBtn = document.getElementById('export-close-btn');
const exportCopyBtn = document.getElementById('export-copy-btn');
const topExportLatexBtn = document.getElementById('top-export-latex-btn');

function generateLatex(model) {
    let latex = "% TikZ Code generated by JUDIT\n";
    latex += "\\begin{tikzpicture}[>=stealth, node distance=2cm, auto]\n";
    latex += "  % Nodes\n";

    // Detect bounds to center or normalize?
    // Just use raw coordinates with a scale factor.
    // Invert Y because canvas Y is down, Latex Y is up.
    const SCALE = 0.02;

    for (const world of model.worlds.values()) {
        const x = (world.x * SCALE).toFixed(2);
        const y = (-world.y * SCALE).toFixed(2); // Invert Y
        let label = world.name;

        // Add valuation to label if any atoms are true
        const trueAtoms = [];
        for (const [atom, val] of world.valuation.entries()) {
            if (val === true) trueAtoms.push(atom);
        }
        if (trueAtoms.length > 0) {
            label += `: ${trueAtoms.join(',')}`;
        }

        latex += `  \\node[circle, draw, minimum size=1cm] (${world.id}) at (${x},${y}) {${label}};\n`;
    }

    latex += "\n  % Edges\n";
    for (const rel of model.relations) {
        // Find if there is a reverse edge to handle bending?
        // Simple straight lines for now, or curved if self-loop.
        if (rel.sourceId === rel.targetId) {
            latex += `  \\draw[->] (${rel.sourceId}) to [loop above] (${rel.targetId});\n`;
        } else {
            // Check for bidirectional to curve?
            // Simple: Just straight line
            latex += `  \\draw[->] (${rel.sourceId}) -- (${rel.targetId});\n`;
        }
    }

    latex += "\\end{tikzpicture}";
    return latex;
}

if (topExportLatexBtn) {
    topExportLatexBtn.addEventListener('click', () => {
        const latex = generateLatex(model);
        exportTextarea.value = latex;
        exportModal.style.display = 'flex';
    });
}

if (exportCloseBtn) {
    exportCloseBtn.addEventListener('click', () => {
        exportModal.style.display = 'none';
    });
}

if (exportCopyBtn) {
    exportCopyBtn.addEventListener('click', () => {
        exportTextarea.select();
        document.execCommand('copy');
        const originalText = exportCopyBtn.innerText;
        exportCopyBtn.innerText = "Copied!";
        setTimeout(() => exportCopyBtn.innerText = originalText, 1500);
    });
}

